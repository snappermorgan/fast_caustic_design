#include "mesh.h"

Mesh::Mesh(double width, double height, int res_x, int res_y)
    : Mesh("square", res_x, res_y, width, height) {}

Mesh::Mesh(const std::string &shape, int res_x, int res_y, double width,
           double height) {
  // set physical size of mesh
  this->width = width;
  this->height = height;

  // set poisson domain resolution
  this->res_x = res_x;
  this->res_y = res_y;

  // Generate structured (square) mesh
  generate_structured_mesh(res_x, res_y, width, height, this->triangles,
                           this->source_points);

  build_vertex_to_triangles();
}

Mesh::Mesh(std::vector<std::vector<double>> new_points,
           std::vector<std::vector<unsigned int>> new_triangles) {
  for (int i = 0; i < new_points.size(); i++) {
    this->source_points.push_back(new_points[i]);
  }

  for (int i = 0; i < new_triangles.size(); i++) {
    this->triangles.push_back(new_triangles[i]);
  }

  build_vertex_to_triangles();
}

Mesh::~Mesh() {}

void find_perimeter_vertices(int nx, int ny,
                             std::vector<size_t> &perimeter_vertices) {
  // Top row
  for (size_t i = 0; i < nx; ++i) {
    perimeter_vertices.push_back(i);
  }

  // Right column
  for (size_t i = nx - 1; i < nx * ny; i += nx) {
    perimeter_vertices.push_back(i);
  }

  // Bottom row
  for (size_t i = nx * (ny - 1) + nx - 1; i > nx * (ny - 1) - 1; --i) {
    perimeter_vertices.push_back(i);
  }

  // Left column
  for (size_t i = nx * (ny - 1) - nx; i > nx - 1; i -= nx) {
    perimeter_vertices.push_back(i);
  }
}

void save_solid_obj(std::vector<std::vector<double>> &front_points,
                    std::vector<std::vector<double>> &back_points,
                    std::vector<std::vector<unsigned int>> &triangles,
                    double thickness, double width, double height, int res_x,
                    int res_y, const std::string &filename) {
  size_t num_points = front_points.size();

  std::ofstream file(filename);
  if (!file.is_open()) {
    std::cerr << "Error opening file: " << filename << std::endl;
    return;
  }

  // Find maximum height
  double min_h = 0;
  for (int i = 0; i < num_points; i++) {
    double h = front_points[i][2];

    if (min_h > h) {
      min_h = h;
    }
  }

  file << "# Generated by the software algorithm written by Dylan Missuwe"
       << "\n";
  file << "# The algorithm used to create the lens is based on the paper "
       << "\"Poisson-Based Continuous Surface Generation for Goal-Based "
          "Caustics\" "
       << "by Yue et al (2014)" << "\n";

  // Center the mesh at origin: transform [0, width] -> [-width/2, width/2]
  double half_w = width / 2.0;
  double half_h = height / 2.0;

  // Curved mesh verts on the bottom
  for (const auto &point : front_points) {
    file << "v " << (width - point[0] - half_w) << " "
         << (height - point[1] - half_h) << " " << -(point[2]) << "\n";
  }

  // Flat mesh verts on the bottom
  for (const auto &point : back_points) {
    file << "v " << (width - point[0] - half_w) << " "
         << (height - point[1] - half_h) << " " << -thickness - min_h << "\n";
  }

  // Curved mesh triangles on the top
  for (const auto &triangle : triangles) {
    file << "f " << triangle[0] + 1 << " " << triangle[1] + 1 << " "
         << triangle[2] + 1 << "\n";
  }

  // Flat mesh triangles on the bottom
  for (const auto &triangle : triangles) {
    file << "f " << triangle[0] + num_points + 1 << " "
         << triangle[2] + num_points + 1 << " " << triangle[1] + num_points + 1
         << "\n";
  }

  // Generate triangles connecting top and bottom mesh
  std::vector<size_t> perimeter_verts;
  find_perimeter_vertices(res_x, res_y, perimeter_verts);

  for (size_t i = 0; i < perimeter_verts.size(); ++i) {
    size_t top_idx = perimeter_verts[i];
    size_t bottom_idx = perimeter_verts[i] + num_points;
    size_t next_top_idx = perimeter_verts[(i + 1) % perimeter_verts.size()];
    size_t next_bottom_idx =
        perimeter_verts[(i + 1) % perimeter_verts.size()] + num_points;

    file << "f " << top_idx + 1 << " " << bottom_idx + 1 << " "
         << next_bottom_idx + 1 << "\n";
    file << "f " << top_idx + 1 << " " << next_bottom_idx + 1 << " "
         << next_top_idx + 1 << "\n";
    // file << "f " << top_idx + 1 << " " << next_bottom_idx + 1 << " " <<
    // bottom_idx + 1 << "\n"; file << "f " << top_idx + 1 << " " <<
    // next_top_idx + 1 << " " << next_bottom_idx + 1 << "\n";
  }

  // std::cout << "Exported model \"" << filename << "\"" << std::endl;
}

void Mesh::generate_poked_mesh(
    int nx, int ny, double width, double height,
    std::vector<std::vector<unsigned int>> &triangles,
    std::vector<std::vector<double>> &points) {
  double dx = width / (double)nx;
  double dy = height / (double)ny;

  // grid vertices
  for (int y = 0; y < ny + 1; y++) {
    for (int x = 0; x < nx + 1; x++) {
      points.push_back({x * dx, y * dy, 0.0f});
    }
  }

  // center vertices
  for (int y = 0; y < ny; y++) {
    for (int x = 0; x < nx; x++) {
      points.push_back({(x + 0.5f) * dx, (y + 0.5f) * dy, 0.0f});
    }
  }

  int offset = (nx + 1) * (ny + 1);
  for (int y = 0; y < ny; y++) {
    for (int x = 0; x < nx; x++) {
      unsigned int upper_left = x + y * (nx + 1);
      unsigned int upper_right = (x + 1) + y * (nx + 1);
      unsigned int lower_left = x + (y + 1) * (nx + 1);
      unsigned int lower_right = (x + 1) + (y + 1) * (nx + 1);
      unsigned int center = offset + x + y * (nx);

      triangles.push_back({upper_left, upper_right, center});
      triangles.push_back({lower_left, upper_left, center});
      triangles.push_back({lower_right, lower_left, center});
      triangles.push_back({upper_right, lower_right, center});
    }
  }
}

// generates a structured triangulation used for the parameterization
void Mesh::generate_structured_mesh(
    int nx, int ny, double width, double height,
    std::vector<std::vector<unsigned int>> &triangles,
    std::vector<std::vector<double>> &points) {
  // Debug output removed for clean JSON mode
  // Generate points
  for (int i = 0; i < ny; ++i) {
    for (int j = 0; j < nx; ++j) {
      double x = static_cast<double>(j) * width / (nx - 1);
      double y = static_cast<double>(i) * height / (ny - 1);
      points.push_back({x, y, 0.0});
    }
  }

  // Generate triangles
  for (int i = 0; i < ny - 1; ++i) {
    for (int j = 0; j < nx - 1; ++j) {
      unsigned int idx = i * nx + j;
      triangles.push_back({idx, idx + 1, idx + nx});
      triangles.push_back({idx + nx, idx + 1, idx + nx + 1});
    }
  }
}

// build mapping from vertices to adjecent triangles -> used for creating dual
// cells
void Mesh::build_vertex_to_triangles() {
  for (int i = 0; i < this->triangles.size(); ++i) {
    const std::vector<unsigned int> &triangle = this->triangles[i];

    for (int vertex : triangle) {
      if (this->vertex_to_triangles.find(vertex) ==
          this->vertex_to_triangles.end()) {
        this->vertex_to_triangles[vertex] = std::vector<int>();
      }

      this->vertex_to_triangles[vertex].push_back(i);
    }
  }
}

// find triangles, edges, and neighboring vertices connected to a specific
// vertex by index
std::tuple<std::vector<std::pair<int, int>>, std::vector<int>, std::vector<int>>
Mesh::find_adjacent_elements(int vertex_index) {
  std::unordered_set<std::pair<int, int>, HashPair> adjacent_edges;
  std::unordered_set<int> adjacent_triangles;
  std::unordered_set<int> neighboring_vertices;

  // Find triangles containing the vertex
  auto triangles_containing_vertex = vertex_to_triangles.find(vertex_index);
  if (triangles_containing_vertex != vertex_to_triangles.end()) {
    for (int triangle_index : triangles_containing_vertex->second) {
      adjacent_triangles.insert(triangle_index);
      const std::vector<unsigned int> &triangle = triangles[triangle_index];

      // Find edges and neighboring vertices directly connected to the vertex
      for (int j = 0; j < 3; ++j) {
        int v1 = triangle[j];
        int v2 = triangle[(j + 1) % 3];

        // Add edge if it involves the vertex
        if (vertex_index == v1 || vertex_index == v2) {
          adjacent_edges.insert(
              std::make_pair(std::min(v1, v2), std::max(v1, v2)));
        }

        // Add neighboring vertex (other vertex of the edge if it's not the
        // input vertex)
        if (v1 == vertex_index) {
          neighboring_vertices.insert(v2);
        } else if (v2 == vertex_index) {
          neighboring_vertices.insert(v1);
        }
      }
    }
  }

  // Convert sets to vectors
  std::vector<std::pair<int, int>> adjacent_edges_vector(adjacent_edges.begin(),
                                                         adjacent_edges.end());
  std::vector<int> adjacent_triangles_vector(adjacent_triangles.begin(),
                                             adjacent_triangles.end());
  std::vector<int> neighboring_vertices_vector(neighboring_vertices.begin(),
                                               neighboring_vertices.end());

  return std::make_tuple(adjacent_edges_vector, adjacent_triangles_vector,
                         neighboring_vertices_vector);
}

std::vector<double>
calculate_polygon_centroid(std::vector<std::vector<double>> vertices) {
  std::vector<double> centroid;
  centroid.push_back(0.0);
  centroid.push_back(0.0);

  double signed_area = 0;

  for (int i = 0; i < vertices.size(); i++) {
    double x0 = vertices[i][0];
    double y0 = vertices[i][1];
    double x1 = vertices[(i + 1) % vertices.size()][0];
    double y1 = vertices[(i + 1) % vertices.size()][1];

    // Shoelace formula
    double area = (x0 * y1) - (x1 * y0);
    signed_area += area;
    centroid[0] += (x0 + x1) * area;
    centroid[1] += (y0 + y1) * area;
  }

  signed_area *= 0.5;
  centroid[0] /= 6 * signed_area;
  centroid[1] /= 6 * signed_area;

  return centroid;
}

double calculate_polygon_area_vec(
    const std::vector<std::vector<double>> input_polygon) {
  if (input_polygon.size() < 3) {
    return 0.0;
  }

  size_t n = input_polygon.size();
  double area = 0.0;

  for (int i = 0; i < n; i++) {
    double x1 = input_polygon[i][0];
    double y1 = input_polygon[i][1];
    double x2 = input_polygon[(i + 1) % n][0];
    double y2 = input_polygon[(i + 1) % n][1];
    area += (x1 * y2) - (x2 * y1);
  }

  // Take the absolute value and divide by 2
  area = 0.5 * (area);

  return area;
}

void Mesh::find_vertex_connectivity(int vertex_index,
                                    std::vector<int> &neighborList,
                                    std::vector<int> &neighborMap) {
  std::unordered_set<int> neighboring_vertices;

  auto triangles_containing_vertex = vertex_to_triangles.find(vertex_index);
  if (triangles_containing_vertex != vertex_to_triangles.end()) {
    for (int triangle_index : triangles_containing_vertex->second) {
      const std::vector<unsigned int> &triangle = triangles[triangle_index];

      for (int j = 0; j < 3; ++j) {
        if (triangle[j] != vertex_index) {
          neighboring_vertices.insert(triangle[j]);
        }
      }
    }

    neighborList.assign(neighboring_vertices.begin(),
                        neighboring_vertices.end());

    std::unordered_map<int, int> neighborIndexMap;
    for (int i = 0; i < neighborList.size(); ++i) {
      neighborIndexMap[neighborList[i]] = i;
    }

    for (int triangle_index : triangles_containing_vertex->second) {
      const std::vector<unsigned int> &triangle = triangles[triangle_index];

      // Find the two neighbors in the triangle
      std::vector<int> other_vertices;
      for (int j = 0; j < 3; ++j) {
        if (triangle[j] != vertex_index) {
          other_vertices.push_back(triangle[j]);
        }
      }

      if (other_vertices.size() == 2) {
        int v1_idx = other_vertices[0];
        int v2_idx = other_vertices[1];

        // Use the map for fast lookup of indices in neighborList
        neighborMap.push_back(neighborIndexMap[v1_idx]);
        neighborMap.push_back(neighborIndexMap[v2_idx]);

        std::vector<std::vector<double>> triangle_points = {
            source_points[vertex_index], // Current vertex
            source_points[v1_idx],       // First neighbor
            source_points[v2_idx]        // Second neighbor
        };
        double area = calculate_polygon_area_vec(triangle_points);

        // Correct orientation if needed
        if (area < 0.0) {
          std::swap(neighborMap[neighborMap.size() - 1],
                    neighborMap[neighborMap.size() - 2]);
        }
      }
    }
  }
}

bool Mesh::is_boundary_vertex(
    int vertex_index, std::vector<std::pair<int, int>> &boundary_edges) {
  std::unordered_map<std::pair<int, int>, int, HashPair> edge_triangle_count;
  for (int triangle_index : vertex_adjecent_triangles[vertex_index]) {
    const std::vector<unsigned int> &triangle = triangles[triangle_index];
    for (int j = 0; j < 3; ++j) {
      int v1 = triangle[j];
      int v2 = triangle[(j + 1) % 3];
      std::pair<int, int> edge =
          std::make_pair(std::min(v1, v2), std::max(v1, v2));
      edge_triangle_count[edge]++;
    }
  }

  bool is_boundary = false;
  for (const auto &edge : vertex_adjecent_edges[vertex_index]) {
    if (edge_triangle_count[edge] == 1) { // Boundary edge
      boundary_edges.push_back(edge);
      is_boundary = true;
    }
  }

  return is_boundary;
}

void Mesh::build_adjacency_lookups() {
  for (int i = 0; i < source_points.size(); i++) {
    auto [adjacent_edges, adjacent_triangles, neighboring_vertices] =
        find_adjacent_elements(i);
    vertex_adjecent_edges.push_back(adjacent_edges);
    vertex_adjecent_triangles.push_back(adjacent_triangles);
    vertex_adjecent_vertices.push_back(neighboring_vertices);
  }

  for (int i = 0; i < source_points.size(); i++) {
    std::vector<std::pair<int, int>> boundary_edges;
    bool is_boundary = is_boundary_vertex(i, boundary_edges);
    vertex_is_boundary.push_back(is_boundary);
  }
}

std::vector<double> cross_v(std::vector<double> v1, std::vector<double> v2) {
  std::vector<double> result(3);
  result[0] = v1[1] * v2[2] - v1[2] * v2[1];
  result[1] = v1[2] * v2[0] - v1[0] * v2[2];
  result[2] = v1[0] * v2[1] - v1[1] * v2[0];
  return result;
}

double dot_v(std::vector<double> a, std::vector<double> b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

std::vector<double> mult_v(double a, std::vector<double> b) {
  return {a * b[0], a * b[1], a * b[2]};
}

std::vector<double> add_v(std::vector<double> a, std::vector<double> b) {
  return {a[0] + b[0], a[1] + b[1], a[2] + b[2]};
}

std::vector<double> sub_v(std::vector<double> a, std::vector<double> b) {
  return {a[0] - b[0], a[1] - b[1], a[2] - b[2]};
}

double magnitude_v(std::vector<double> a) {
  return std::sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
}

double cot(const std::vector<double> &a, const std::vector<double> &b) {
  auto cross_product = cross_v(a, b);
  double cross_magnitude = magnitude_v(cross_product);

  if (cross_magnitude < 1e-12) {
    // throw std::invalid_argument("Vectors are parallel or one is a zero
    // vector, cotangent undefined.");
    cross_magnitude = 1e-12;
  }

  return dot_v(a, b) / cross_magnitude;
}

std::vector<double> Mesh::compute_laplacian(int i) {
  std::vector<double> laplacian(vertex_adjecent_vertices[i].size(), 0.0f);

  for (int j_index = 0; j_index < vertex_adjecent_vertices[i].size();
       ++j_index) {
    int j = vertex_adjecent_vertices[i][j_index];

    // Find triangles shared between `i` and `j`
    std::vector<int> shared_triangles;
    for (int triangle : vertex_adjecent_triangles[i]) {
      // Check if `j` is one of the vertices in this triangle
      const auto &vertices = triangles[triangle];
      if (std::find(vertices.begin(), vertices.end(), j) != vertices.end()) {
        shared_triangles.push_back(triangle);
      }
    }

    // Handle cases based on the number of shared triangles
    if (shared_triangles.size() == 2) {
      // Interior case: Two triangles are connected
      std::vector<int> k_vertices;
      for (int triangle : shared_triangles) {
        for (int vertex : this->triangles[triangle]) {
          if (vertex != i && vertex != j) {
            k_vertices.push_back(vertex);
            break; // Only one `k` per triangle
          }
        }
      }

      // Ensure we found two `k` vertices
      if (k_vertices.size() != 2) {
        throw std::runtime_error("Error identifying k vertices in triangles.");
      }

      int k1 = k_vertices[0];
      int k2 = k_vertices[1];

      std::vector<double> edge1;
      std::vector<double> edge2;

      edge1 = sub_v(this->source_points[k1], this->source_points[j]);
      edge2 = sub_v(this->source_points[k1], this->source_points[i]);
      double cot_k1 = cot(edge1, edge2);

      edge1 = sub_v(this->source_points[k2], this->source_points[j]);
      edge2 = sub_v(this->source_points[k2], this->source_points[i]);
      double cot_k2 = cot(edge1, edge2);

      laplacian[j_index] += cot_k1 * 0.5;
      laplacian[j_index] += cot_k2 * 0.5;

      // std::cout << "k1=" << k1 << ", k2=" << k2 << std::endl;

    } else if (shared_triangles.size() == 1) {
      // Boundary case: Only one triangle is connected
      int triangle = shared_triangles[0];
      int k = -1;

      // Find the single `k` vertex
      for (int vertex : this->triangles[triangle]) {
        if (vertex != i && vertex != j) {
          k = vertex;
          break;
        }
      }

      if (k == -1) {
        throw std::runtime_error(
            "Error identifying k vertex in boundary triangle.");
      }

      std::vector<double> edge1;
      std::vector<double> edge2;

      edge1 = sub_v(this->source_points[k], this->source_points[j]);
      edge2 = sub_v(this->source_points[k], this->source_points[i]);
      double cot_k = cot(edge1, edge2);

      laplacian[j_index] += cot_k;

      // std::cout << "k=" << k << std::endl;

    } else {
      throw std::runtime_error("No shared triangles between i and j; invalid "
                               "mesh or disconnected vertex.");
    }
  }

  return laplacian;
}

void Mesh::calculate_vertex_laplacians() {
  build_adjacency_lookups();
  vertex_laplacians.clear();

  for (int i = 0; i < this->source_points.size(); i++) {
    vertex_laplacians.push_back(compute_laplacian(i));
  }
}

void Mesh::get_vertex_neighbor_ids(int vertex_id, int &left_vertex,
                                   int &right_vertex, int &top_vertex,
                                   int &bottom_vertex) {
  int y = vertex_id / res_x;
  int x = vertex_id % res_x;

  if (x != 0) {
    left_vertex = (y)*res_x + (x - 1);
  } else {
    left_vertex = -1;
  }

  if (y != 0) {
    top_vertex = (y - 1) * res_x + (x);
  } else {
    top_vertex = -1;
  }

  if (x != res_x - 1) {
    right_vertex = (y)*res_x + (x + 1);
  } else {
    right_vertex = -1;
  }

  if (y != res_y - 1) {
    bottom_vertex = (y + 1) * res_x + (x);
  } else {
    bottom_vertex = -1;
  }
}

std::vector<double> normalize(std::vector<double> p1) {
  std::vector<double> vec(3);
  double squared_len = 0;
  for (int i = 0; i < p1.size(); i++) {
    squared_len += p1[i] * p1[i];
  }

  double len = std::sqrt(squared_len);

  for (int i = 0; i < p1.size(); i++) {
    vec[i] = p1[i] / len;
  }

  return vec;
}

void Mesh::save_solid_obj_source(double thickness,
                                 const std::string &filename) {
  save_solid_obj(this->source_points, this->source_points, this->triangles,
                 thickness, this->width, this->height, this->res_x, this->res_y,
                 filename);
}

bool Mesh::is_border(int vertex_id) {

  int y = vertex_id / res_x;

  int x = vertex_id % res_x;

  if (x == 0) {

    return true;
  }

  if (y == 0) {

    return true;
  }

  if (x == res_x - 1) {

    return true;
  }

  if (y == res_y - 1) {

    return true;
  }

  return false;
}
